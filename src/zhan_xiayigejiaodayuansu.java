//有时可以很巧妙 压入的是索引

//双重否定表"直到"
//相对静止
//错位循环
//压栈配合比较范围 反向顺序配合压栈
/*现在我们有一个int数组，请你找出数组中每个元素的下一个比它大的元素。

给定一个int数组A及数组的大小n，请返回一个int数组，代表每个元素比他大的下一个元素,若不存在则为-1。保证数组中元素均为正整数。

测试样例：
[11,13,10,5,12,21,3],7
返回：[13,21,12,12,21,-1,-1]*/

/*
思路：
从后向前维护一个递减栈。
最右边的那个值肯定没有最大值，所以肯定是-1。初始栈为-1。
从后向前计算：
（1）如果当前元素大于栈顶元素，则栈顶元素退出，如果还是大于栈顶元素，继续退出，一直遍历栈到-1或者小于栈顶元素。这个元素就是就是当前值的下一个比较大的元素。
（2）如果当前元素小于栈顶元素，栈顶元素就是当前值的下一个比较大的元素。*/
import java.util.*;

public class zhan_xiayigejiaodayuansu
{
    public int[] findNext(int[] A, int n)
    {
        Stack<Integer> s=new Stack<Integer>();
        s.push(-1);//压入一个初始化的"-1"
        List<Integer> res=new ArrayList<Integer>();
        for(int i=n-1;i>=0;i--)//每次a[i]不是栈的最顶端 因为之后它判断之后才压入栈的
        {
            int t=s.peek();//得到栈最顶端的值
            while(t!=-1&&A[i]>t)
            {
                s.pop();
                t=s.peek();
            }//取到第一个大于A[i]的值或者-1
            res.add(t);//按照反顺序将每一个结果放进结果列表里
            s.push(A[i]);//按照反顺序将数组元素压入栈内
        }
        int B[]=A;
        for(int i=n-1;i>=0;i--)
        {
            B[i]=res.get(n-1-i);
        }//将结果列表的数据放进数组里
        return B;//返回这个数组
    }
}

